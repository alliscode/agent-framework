// <auto-generated/>

#nullable disable

using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Threading.Tasks;
using AzureAIAgents.Models;

namespace AzureAIAgents
{
    // Data plane generated sub-client.
    /// <summary> The Responses sub-client. </summary>
    public partial class Responses
    {
        private readonly ClientPipeline _pipeline;
        private readonly Uri _endpoint;

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual ClientPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of Responses for mocking. </summary>
        protected Responses()
        {
        }

        /// <summary> Initializes a new instance of Responses. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> Service host. </param>
        internal Responses(ClientPipeline pipeline, Uri endpoint)
        {
            _pipeline = pipeline;
            _endpoint = endpoint;
        }

        /// <summary> Creates a model response. </summary>
        /// <param name="accept"> The <see cref="CreateResponseRequestAccept"/> to use. </param>
        /// <param name="requestBody"> The <see cref="Models.CreateResponse"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="requestBody"/> is null. </exception>
        public virtual async Task<ClientResult<ResponseStreamEvent>> CreateResponseAsync(CreateResponseRequestAccept accept, CreateResponse requestBody)
        {
            Argument.AssertNotNull(requestBody, nameof(requestBody));

            using BinaryContent content = requestBody.ToBinaryContent();
            ClientResult result = await CreateResponseAsync(accept.ToSerialString(), content, null).ConfigureAwait(false);
            return ClientResult.FromValue(ResponseStreamEvent.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Creates a model response. </summary>
        /// <param name="accept"> The <see cref="CreateResponseRequestAccept"/> to use. </param>
        /// <param name="requestBody"> The <see cref="Models.CreateResponse"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="requestBody"/> is null. </exception>
        public virtual ClientResult<ResponseStreamEvent> CreateResponse(CreateResponseRequestAccept accept, CreateResponse requestBody)
        {
            Argument.AssertNotNull(requestBody, nameof(requestBody));

            using BinaryContent content = requestBody.ToBinaryContent();
            ClientResult result = CreateResponse(accept.ToSerialString(), content, null);
            return ClientResult.FromValue(ResponseStreamEvent.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Creates a model response.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateResponseAsync(CreateResponseRequestAccept,Models.CreateResponse)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="accept"> The <see cref="string"/> to use. Allowed values: "application/json" | "text/event-stream". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="accept"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> CreateResponseAsync(string accept, BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNull(accept, nameof(accept));
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateCreateResponseRequest(accept, content, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Creates a model response.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateResponse(CreateResponseRequestAccept,Models.CreateResponse)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="accept"> The <see cref="string"/> to use. Allowed values: "application/json" | "text/event-stream". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="accept"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult CreateResponse(string accept, BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNull(accept, nameof(accept));
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateCreateResponseRequest(accept, content, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Retrieves a model response with the given ID. </summary>
        /// <param name="responseId"> The ID of the response to retrieve. </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="includables"> The <see cref="IEnumerable{T}"/> where <c>T</c> is of type <see cref="Includable"/> to use. </param>
        /// <param name="stream"> If set to true, model response data will be streamed to the client as it is generated using server-sent events. </param>
        /// <param name="startingAfter"> The sequence number of the event after which to start streaming. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ClientResult<ResponseStreamEvent>> GetResponseAsync(string responseId, string accept, IEnumerable<Includable> includables = null, bool? stream = null, int? startingAfter = null)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));
            Argument.AssertNotNull(accept, nameof(accept));

            ClientResult result = await GetResponseAsync(responseId, accept, includables, stream, startingAfter, null).ConfigureAwait(false);
            return ClientResult.FromValue(ResponseStreamEvent.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Retrieves a model response with the given ID. </summary>
        /// <param name="responseId"> The ID of the response to retrieve. </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="includables"> The <see cref="IEnumerable{T}"/> where <c>T</c> is of type <see cref="Includable"/> to use. </param>
        /// <param name="stream"> If set to true, model response data will be streamed to the client as it is generated using server-sent events. </param>
        /// <param name="startingAfter"> The sequence number of the event after which to start streaming. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ClientResult<ResponseStreamEvent> GetResponse(string responseId, string accept, IEnumerable<Includable> includables = null, bool? stream = null, int? startingAfter = null)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));
            Argument.AssertNotNull(accept, nameof(accept));

            ClientResult result = GetResponse(responseId, accept, includables, stream, startingAfter, null);
            return ClientResult.FromValue(ResponseStreamEvent.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Retrieves a model response with the given ID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetResponseAsync(string,string,IEnumerable{Includable},bool?,int?)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="responseId"> The ID of the response to retrieve. </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="includables"> The <see cref="IEnumerable{T}"/> where <c>T</c> is of type <see cref="Includable"/> to use. </param>
        /// <param name="stream"> If set to true, model response data will be streamed to the client as it is generated using server-sent events. </param>
        /// <param name="startingAfter"> The sequence number of the event after which to start streaming. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> GetResponseAsync(string responseId, string accept, IEnumerable<Includable> includables, bool? stream, int? startingAfter, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));
            Argument.AssertNotNull(accept, nameof(accept));

            using PipelineMessage message = CreateGetResponseRequest(responseId, accept, includables, stream, startingAfter, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Retrieves a model response with the given ID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetResponse(string,string,IEnumerable{Includable},bool?,int?)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="responseId"> The ID of the response to retrieve. </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="includables"> The <see cref="IEnumerable{T}"/> where <c>T</c> is of type <see cref="Includable"/> to use. </param>
        /// <param name="stream"> If set to true, model response data will be streamed to the client as it is generated using server-sent events. </param>
        /// <param name="startingAfter"> The sequence number of the event after which to start streaming. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult GetResponse(string responseId, string accept, IEnumerable<Includable> includables, bool? stream, int? startingAfter, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));
            Argument.AssertNotNull(accept, nameof(accept));

            using PipelineMessage message = CreateGetResponseRequest(responseId, accept, includables, stream, startingAfter, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Delete response. </summary>
        /// <param name="responseId"> The ID of the response to delete. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ClientResult<DeleteResponseResponse>> DeleteResponseAsync(string responseId)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));

            ClientResult result = await DeleteResponseAsync(responseId, null).ConfigureAwait(false);
            return ClientResult.FromValue(DeleteResponseResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Delete response. </summary>
        /// <param name="responseId"> The ID of the response to delete. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ClientResult<DeleteResponseResponse> DeleteResponse(string responseId)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));

            ClientResult result = DeleteResponse(responseId, null);
            return ClientResult.FromValue(DeleteResponseResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Delete response.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteResponseAsync(string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="responseId"> The ID of the response to delete. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> DeleteResponseAsync(string responseId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));

            using PipelineMessage message = CreateDeleteResponseRequest(responseId, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Delete response.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteResponse(string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="responseId"> The ID of the response to delete. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult DeleteResponse(string responseId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));

            using PipelineMessage message = CreateDeleteResponseRequest(responseId, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Cancel response. </summary>
        /// <param name="responseId"> The ID of the response to cancel. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ClientResult<Response>> CancelResponseAsync(string responseId)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));

            ClientResult result = await CancelResponseAsync(responseId, null).ConfigureAwait(false);
            return ClientResult.FromValue(Response.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Cancel response. </summary>
        /// <param name="responseId"> The ID of the response to cancel. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ClientResult<Response> CancelResponse(string responseId)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));

            ClientResult result = CancelResponse(responseId, null);
            return ClientResult.FromValue(Response.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Cancel response.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CancelResponseAsync(string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="responseId"> The ID of the response to cancel. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> CancelResponseAsync(string responseId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));

            using PipelineMessage message = CreateCancelResponseRequest(responseId, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Cancel response.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CancelResponse(string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="responseId"> The ID of the response to cancel. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult CancelResponse(string responseId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));

            using PipelineMessage message = CreateCancelResponseRequest(responseId, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Returns a list of input items for a given response. </summary>
        /// <param name="responseId"> The ID of the response to retrieve. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ClientResult<ResponseItemList>> GetInputItemsAsync(string responseId, int? limit = null, ListConversationsRequestOrder? order = null, string after = null, string before = null)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));

            ClientResult result = await GetInputItemsAsync(responseId, limit, order?.ToSerialString(), after, before, null).ConfigureAwait(false);
            return ClientResult.FromValue(ResponseItemList.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Returns a list of input items for a given response. </summary>
        /// <param name="responseId"> The ID of the response to retrieve. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ClientResult<ResponseItemList> GetInputItems(string responseId, int? limit = null, ListConversationsRequestOrder? order = null, string after = null, string before = null)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));

            ClientResult result = GetInputItems(responseId, limit, order?.ToSerialString(), after, before, null);
            return ClientResult.FromValue(ResponseItemList.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Returns a list of input items for a given response.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetInputItemsAsync(string,int?,global::AzureAIAgents.Models.ListConversationsRequestOrder?,string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="responseId"> The ID of the response to retrieve. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> GetInputItemsAsync(string responseId, int? limit, string order, string after, string before, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));

            using PipelineMessage message = CreateGetInputItemsRequest(responseId, limit, order, after, before, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Returns a list of input items for a given response.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetInputItems(string,int?,global::AzureAIAgents.Models.ListConversationsRequestOrder?,string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="responseId"> The ID of the response to retrieve. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="responseId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="responseId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult GetInputItems(string responseId, int? limit, string order, string after, string before, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(responseId, nameof(responseId));

            using PipelineMessage message = CreateGetInputItemsRequest(responseId, limit, order, after, before, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Returns the list of all responses. </summary>
        /// <param name="agentName"> Filter by agent name. If provided, only responses associated with the specified agent will be returned. </param>
        /// <param name="agentVersion"> Filter by agent version. If provided, only responses associated with the specified agent version will be returned. </param>
        /// <param name="conversationId"> Filter by conversation ID. If provided, only responses associated with the specified conversation will be returned. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <remarks> Get responses. </remarks>
        public virtual async Task<ClientResult<Error>> GetResponsesAsync(string agentName = null, string agentVersion = null, string conversationId = null, int? limit = null, ListConversationsRequestOrder? order = null, string after = null, string before = null)
        {
            ClientResult result = await GetResponsesAsync(agentName, agentVersion, conversationId, limit, order?.ToSerialString(), after, before, null).ConfigureAwait(false);
            return ClientResult.FromValue(Error.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Returns the list of all responses. </summary>
        /// <param name="agentName"> Filter by agent name. If provided, only responses associated with the specified agent will be returned. </param>
        /// <param name="agentVersion"> Filter by agent version. If provided, only responses associated with the specified agent version will be returned. </param>
        /// <param name="conversationId"> Filter by conversation ID. If provided, only responses associated with the specified conversation will be returned. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <remarks> Get responses. </remarks>
        public virtual ClientResult<Error> GetResponses(string agentName = null, string agentVersion = null, string conversationId = null, int? limit = null, ListConversationsRequestOrder? order = null, string after = null, string before = null)
        {
            ClientResult result = GetResponses(agentName, agentVersion, conversationId, limit, order?.ToSerialString(), after, before, null);
            return ClientResult.FromValue(Error.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Returns the list of all responses.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetResponsesAsync(string,string,string,int?,global::AzureAIAgents.Models.ListConversationsRequestOrder?,string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="agentName"> Filter by agent name. If provided, only responses associated with the specified agent will be returned. </param>
        /// <param name="agentVersion"> Filter by agent version. If provided, only responses associated with the specified agent version will be returned. </param>
        /// <param name="conversationId"> Filter by conversation ID. If provided, only responses associated with the specified conversation will be returned. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> GetResponsesAsync(string agentName, string agentVersion, string conversationId, int? limit, string order, string after, string before, RequestOptions options)
        {
            using PipelineMessage message = CreateGetResponsesRequest(agentName, agentVersion, conversationId, limit, order, after, before, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Returns the list of all responses.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetResponses(string,string,string,int?,global::AzureAIAgents.Models.ListConversationsRequestOrder?,string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="agentName"> Filter by agent name. If provided, only responses associated with the specified agent will be returned. </param>
        /// <param name="agentVersion"> Filter by agent version. If provided, only responses associated with the specified agent version will be returned. </param>
        /// <param name="conversationId"> Filter by conversation ID. If provided, only responses associated with the specified conversation will be returned. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult GetResponses(string agentName, string agentVersion, string conversationId, int? limit, string order, string after, string before, RequestOptions options)
        {
            using PipelineMessage message = CreateGetResponsesRequest(agentName, agentVersion, conversationId, limit, order, after, before, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        internal PipelineMessage CreateCreateResponseRequest(string accept, BinaryContent content, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "POST";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/openai/responses", false);
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", accept);
            request.Headers.Set("Content-Type", "application/json");
            request.Content = content;
            message.Apply(options);
            return message;
        }

        internal PipelineMessage CreateGetResponseRequest(string responseId, string accept, IEnumerable<Includable> includables, bool? stream, int? startingAfter, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "GET";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/openai/responses/", false);
            uri.AppendPath(responseId, true);
            if (includables != null && !(includables is ChangeTrackingList<Includable> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in includables)
                {
                    uri.AppendQuery("include[]", param.ToSerialString(), true);
                }
            }
            if (stream != null)
            {
                uri.AppendQuery("stream", stream.Value, true);
            }
            if (startingAfter != null)
            {
                uri.AppendQuery("starting_after", startingAfter.Value, true);
            }
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", accept);
            message.Apply(options);
            return message;
        }

        internal PipelineMessage CreateDeleteResponseRequest(string responseId, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "DELETE";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/openai/responses/", false);
            uri.AppendPath(responseId, true);
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            message.Apply(options);
            return message;
        }

        internal PipelineMessage CreateCancelResponseRequest(string responseId, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "POST";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/openai/responses/", false);
            uri.AppendPath(responseId, true);
            uri.AppendPath("/cancel", false);
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            message.Apply(options);
            return message;
        }

        internal PipelineMessage CreateGetInputItemsRequest(string responseId, int? limit, string order, string after, string before, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "GET";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/openai/responses/", false);
            uri.AppendPath(responseId, true);
            uri.AppendPath("/input_items", false);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (order != null)
            {
                uri.AppendQuery("order", order, true);
            }
            if (after != null)
            {
                uri.AppendQuery("after", after, true);
            }
            if (before != null)
            {
                uri.AppendQuery("before", before, true);
            }
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            message.Apply(options);
            return message;
        }

        internal PipelineMessage CreateGetResponsesRequest(string agentName, string agentVersion, string conversationId, int? limit, string order, string after, string before, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "GET";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/openai/responses", false);
            if (agentName != null)
            {
                uri.AppendQuery("agent_name", agentName, true);
            }
            if (agentVersion != null)
            {
                uri.AppendQuery("agent_version", agentVersion, true);
            }
            if (conversationId != null)
            {
                uri.AppendQuery("conversation_id", conversationId, true);
            }
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (order != null)
            {
                uri.AppendQuery("order", order, true);
            }
            if (after != null)
            {
                uri.AppendQuery("after", after, true);
            }
            if (before != null)
            {
                uri.AppendQuery("before", before, true);
            }
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            message.Apply(options);
            return message;
        }

        private static PipelineMessageClassifier _pipelineMessageClassifier200;
        private static PipelineMessageClassifier PipelineMessageClassifier200 => _pipelineMessageClassifier200 ??= PipelineMessageClassifier.Create(stackalloc ushort[] { 200 });
    }
}
